---
title: "cpp基础知识"
date: 2022-09-11T23:51:00+08:00
description: "cpp基础知识汇总"
categories: [
	"C++"
]	
tags: [
   
]
draft: false
---

+ 数组`int a[] = {1, 2, 3,4}`, a和&a, &a[0]的区别：
  + a为数组名，值是指针常量， 类型是指向元素类型的**常量指针**, 只有**两种场合下数组名并不表现为指针常量**：一是`sizeof`操作符，另一个是取地址操作符`&`
  + &a为**数组的**指针，`int(*p)[4] = &a; // 指向4个int类型的数组指针`
  + &a[0]为指向首元素的指针，`int* p = &a[0];`
  + 三者值相等，都等于首元素的地址
  + `sizeof(a)`等于整个数组所占字节，`sizeof(&a) ==sizeof(&a[0]) `为指针所占字节大小（4或8字节）
  + `&a + 1`偏移整个数组所占字节大小，`a + 1` 和`&a[0] + 1`偏移元素所占字节大小
+ `char[] str = "hello";`和`char* pstr = "hello";`的区别：
  + 第一个为字符串数组，第二个为字符串常量
  + `sizoef(str) = strlen(str)+1`，char数组后面会自动填充字符串结束符`\0`, `sizeof(pstr)`为指针大小
  + `str[1] = 'a'`修改是安全的，而对`*(ptr+1) = 'a'`修改是不安全的；
+ `const`:
  + 在`*`右边 则修饰 指针它本身，否则修饰它指向的内容
  + 修饰左值引用可以引用右值
  + 修饰成员函数可构成重载
+ 对象指针为空指针可以调用成员函数，原因是函数地址在编译期已经确定了
+ `explicit`关键字是修饰构造函数的，表明不可以隐式转换成该类型对象
+ 有`int`和`int*`形参两个构成重载的函数，当传入`NULL`时将调用int形参版本的函数，原因是c++的`NULL`为0的宏。c++11引入`nullptr`可以解决这种调用不符本意的问题。


